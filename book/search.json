[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Empirical Finance with Python",
    "section": "",
    "text": "Get started"
  },
  {
    "objectID": "about-minimal.html#purpose-and-audience",
    "href": "about-minimal.html#purpose-and-audience",
    "title": "1  About this book",
    "section": "1.1 Purpose and Audience",
    "text": "1.1 Purpose and Audience\nThe principal objective of this book is to offer a thorough and accessible guide to the statistical and econometric techniques used in empirical finance. This book has been written for advanced undergraduate and graduate students with a robust understanding of finance and economics, but who may be novices in programming and econometrics.\nWe understand that students in finance often aspire to bolster their analytical capabilities with more advanced statistical techniques, but may find it challenging to navigate the technical complexities of econometrics. This book aims to demystify these techniques, making them accessible and relatable to problems and scenarios commonly encountered in finance.\nIn addition, “Empirical Finance with Python” provides an introduction to Python programming, demonstrating how it can be harnessed to implement the statistical and econometric methods discussed. No prior programming experience is required, making this book a valuable asset for students beginning their journey in Python, as well as finance professionals and academics seeking to incorporate Python programming into their analytical toolbox.\nEven those with some familiarity with Python will find this book useful, as it offers practical insights into the application of programming in empirical finance, supported by cutting-edge AI-based tools like ChatGPT and GitHub Copilot.\nA unique feature of our approach is the integration of Python into the practical applications of statistical and econometric methods in finance. We believe that learning by doing is the most effective way to master new skills. Thus, we present real-world scenarios and datasets, enabling you to see the power and efficacy of these techniques in action.\nOur goal is that by the end of this book, you will not only have a solid grounding in modern Python programming, but you will also have a comprehensive understanding of its application in empirical finance using statistical and econometric techniques. We look forward to guiding you through this exciting journey into the world of empirical finance, statistics, econometrics, and Python programming."
  },
  {
    "objectID": "introduction-to-python/install/index.html#local-installation",
    "href": "introduction-to-python/install/index.html#local-installation",
    "title": "2  Installing Python",
    "section": "2.1 Local installation",
    "text": "2.1 Local installation\nThe most common way to use Python is to install it on your computer. This is called a local installation. The advantage of a local installation is that you can use Python even if you don’t have an internet connection. The disadvantage is that you need to install Python and the tools we use on your computer. This can be a bit tricky, especially if you are new to programming. The instructions below will guide you through the process of installing the following tools:\n\nPython: The Python interpreter, which allows you to run Python code.\nPoetry: A package manager for Python. We use it to manage the external libraries we use in our projects.\nVisual Studio Code: A code editor that we use to write Python code.\nGit and GitHub: We use Git to manage our code and GitHub to host our code online and collaborate with others.\nThe instructions will provide you with a working Python environment that you can use to follow along with the examples in the next chapter. I cover these tools in more detail in later chapters.\n\n\n2.1.1 Python\n\n Mac Linux Windows\n\n\nMac OS comes with Python pre-installed. However, it might not be the latest version of Python, so I recommend installing a fresh version from the official distribution at python.org.\n\n\nMost Linux distributions come with Python pre-installed. However, it might not be the latest version of Python, so I recommend installing a fresh version from the official distribution at python.org.\n\n\nWindows does not have a built-in Python interpreter, so you will need to install it. I recommend installing a fresh version from the official distribution at python.org.\n\n\n\n\n\n2.1.2 Poetry\n\n Mac Linux Windows\n\n\nMost Python projects use external libraries. For example, we use the pandas library for data analysis. To manage these libraries, we need a package manager. I recommend using Poetry.\nInstallation instructions can be found here.\nBy default, Poetry installs Python for each project in the ~/Library/Caches/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environmnent is deleted as well. To enable this, run the following command in the Terminal app:\npoetry config virtualenvs.in-project true\n\n\nMost Python projects use external libraries. For example, we use the pandas library for data analysis. To manage these libraries, we need a package manager. I recommend using Poetry.\nInstallation instructions can be found here.\nBy default, Poetry installs Python for each project in the ~/.cache/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environmnent is deleted as well. To enable this, run the following command in the terminal:\npoetry config virtualenvs.in-project true\n\n\nMost Python projects use external libraries. For example, we use the pandas library for data analysis. To manage these libraries, we need a package manager. I recommend using Poetry.\nInstallation instructions can be found here.\nNote: Unless you are using the Windows Subsystem for Linux (WSL), you should follow the instructions for Windows PowerShell.\nMost Python projects use external libraries. For example, we use the pandas library for data analysis. To manage these libraries, we need a package manager. I recommend using Poetry.\nInstallation instructions can be found here.\nBy default, Poetry installs Python for each project in the ~/.cache/pypoetry/virtualenvs/ directory. I prefer to have it in the project directory, that way if, I delete the directory, then the environmnent is deleted as well. To enable this, run the following command in Powershell:\npoetry config virtualenvs.in-project true\n\n\n\n\n\n2.1.3 Visual Studio Code\n\n Mac Linux Windows\n\n\nVisual Studio Code is a free source-code editor made by Microsoft. Features include support for debugging, syntax highlighting and intelligent code completion. Users can install extensions that add additional functionality.\nDownload Visual Studio Code from here.\n\n\nVisual Studio Code is a free source-code editor made by Microsoft. Features include support for debugging, syntax highlighting and intelligent code completion. Users can install extensions that add additional functionality.\nDownload Visual Studio Code from here.\n\n\nVisual Studio Code is a free source-code editor made by Microsoft. Features include support for debugging, syntax highlighting and intelligent code completion. Users can install extensions that add additional functionality.\nDownload Visual Studio Code from here.\n\n\n\n\n\n2.1.4 Git and GitHub\nWe rely on Git and GitHub to manage our code. Git is a version control system that allows us to track changes to our code. GitHub is a website that hosts Git repositories.\n\n Mac Linux Windows\n\n\nWe rely on Git and GitHub to manage our code. Git is a version control system that allows us to track changes to our code. GitHub is a website that hosts Git repositories. Git is already installed on Mac OS as a command-line tool. You can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop.\nTo follow along the coming chapters, you will need to create a GitHub account. You can create a free account at https://github.com/.\nGitHub offers many benefits to students and educator, including a free access to GitHub Copilot and extra free hours for GitHub Codespaces. I highly recommend applying at GitHub Education if you are eligible.\n\n\nWe rely on Git and GitHub to manage our code. Git is a version control system that allows us to track changes to our code. GitHub is a website that hosts Git repositories. Git is already installed on Linux as a command-line tool. You can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop.\nTo follow along the coming chapters, you will need to create a GitHub account. You can create a free account at https://github.com/.\nGitHub offers many benefits to students and educator, including a free access to GitHub Copilot and extra free hours for GitHub Codespaces. I highly recommend applying at GitHub Education if you are eligible.\n\n\nWe rely on Git and GitHub to manage our code. Git is a version control system that allows us to track changes to our code. GitHub is a website that hosts Git repositories.\nTo use Git on Windows, you need to install the Git client, which is a command-line tool.\nYou can also use Git directly in VS Code, or using a GUI client such as GitHub Desktop, but you need to first install the Git client. I prefer to use the VS Code integration or the command-line tool, but many beginners prefer to use GitHub Desktop.\nTo follow along the coming chapters, you will need to create a GitHub account. You can create a free account at https://github.com/.\nGitHub offers many benefits to students and educator, including a free access to GitHub Copilot and extra free hours for GitHub Codespaces. I highly recommend applying at GitHub Education if you are eligible."
  },
  {
    "objectID": "introduction-to-python/install/index.html#github-codespaces",
    "href": "introduction-to-python/install/index.html#github-codespaces",
    "title": "2  Installing Python",
    "section": "2.2 Python in the cloud using Github Codespaces",
    "text": "2.2 Python in the cloud using Github Codespaces\nMany online platforms allow you to develop and run Python code without installing anything on your computer. If you want to use a cloud-based solution, I recommend using GitHub Codespaces.\nAll you need is a GitHub account. However, note that GitHub Codespaces is not free. At the time of this writing, you get 60 hours per month for free, or 90 hours if you signed up for the GitHub Student Developer Pack (this is for a 2-core machine, which is the smallest machine available). After that, you have to pay for it (the current rate is USD 0.18 per hour).\nMake sure to shut down your Codespace when you are not using it, otherwise you will run out of free hours very quickly.\nSetting up a new Codespace is not hard, but it is a bit long, so we come back to it in a later chapter. For now, I have prepared a template repository to get started and run the code in the next chapter."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#introduction",
    "href": "introduction-to-python/python-basics/index.html#introduction",
    "title": "3  Python Basics",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nIn this chapter, we lay the foundation for your programming skills by exploring the basic syntax of Python. My aim is to make this process as accessible as possible for non-programmers, while giving you the necessary tools to excel in the world of empirical finance research.\nThe objectives of this chapter are to:\n\nProvide a gentle introduction to the basic syntax of Python, allowing you to read and understand Python code.\nEnable you to write simple programs that will serve as building blocks for more advanced applications.\nEquip you with the knowledge and confidence to further explore advanced topics in Python and its applications in finance.\n\nBy the end of this chapter, you will have a solid grasp of Python’s basic syntax, empowering you to use it as a versatile tool for finance-related tasks. Remember, the key to success in learning any programming language is practice. As you work through this chapter, be sure to experiment with the examples provided and try writing your own code to reinforce your understanding.\nLet’s dive into the world of Python and begin your journey toward becoming a proficient financial empiricist."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#data-types",
    "href": "introduction-to-python/python-basics/index.html#data-types",
    "title": "3  Python Basics",
    "section": "3.2 Data types",
    "text": "3.2 Data types\nThe Python language offers many built-in fundamental data types. These data types serve as the building blocks for working with different kinds of data, which is critical in many applications. The basic data types you should be familiar with are presented in Table 3.1.\n\n\nTable 3.1: Main data types in Python\n\n\n\n\n\n\n\n\nName\nType\nDescription\nExample\n\n\n\n\nInteger\nint\nIntegers represent whole positive and negative numbers. They are used for counting, indexing, and various arithmetic operations.\n1\n\n\nFloat-Point Number\nfloat\nFloats represent real numbers with decimals. They are used for working with financial data that require precision, such as interest rates, stock prices, and percentages.\n1.0\n\n\nComplex\ncomplex\nComplex numbers consist of real and imaginary parts, represented as a + bj. While less commonly used in finance, they may be relevant in specific advanced applications, such as signal processing or quantitative finance.\n1.0 + 2.0j\n\n\nBoolean\nbool\nBooleans represent the truth values of True and False. They are used in conditional statements, comparisons, and other logical operations.\nTrue\n\n\nText String\nstr\nStrings are sequences of characters used for storing and manipulating text data, such as stock symbols, company names, or descriptions.\n\"Hello\"\n\n\nBytes\nbytes\nBytes are sequences of integers in the range of 0-255, often used for representing binary data or encoding text. Bytes may be used when working with binary file formats or network communication.\nb\"Hello\"\n\n\nNone\nNone\nNone is a special data type representing the absence of a value or a null value. It is used to signify that a variable has not been assigned a value or that a function returns no value.\nNone\n\n\n\n\n\n3.2.1 Literals\nA literal is a notation for representing a fixed value in source code. For example, 42 is a literal for the integer value of forty-two. The following are examples of literals in Python. Each code block contains code and is followed by the output of the code.\n\n3.2.1.1 int\nint literals are written as positive and negative whole numbers.\n\n42\n\n42\n\n\n\n-99\n\n-99\n\n\nThey can also include underscores to make them more readable.\n\n1_000_000\n\n1000000\n\n\n\n\n3.2.1.2 float\nfloat literals are written as decimal numbers.\n\n2.25\n\n2.25\n\n\nThey can be written in scientific notation by using e to indicate the exponent.\n\n2.25e8\n\n225000000.0\n\n\nTo define a whole number literal as a float instead of an int, you can append a decimal point to the number.\n\n2.0\n\n2.0\n\n\n\n\n3.2.1.3 complex\nComplex numbers consist of a real part and an imaginary part, represented as a + bj.\n\n2.3 + 4.5j\n\n(2.3+4.5j)\n\n\n\n\n3.2.1.4 None\nNone is a special data type that represents the absence of a value or a null value. It is used to signify that a variable has not been assigned a value or that a function returns no value.\n\nNone\n\n\n\n3.2.1.5 bool\nbool is a data type that represents the truth values of True and False. They are used in conditional statements, comparisons, and other logical operations.\n\nTrue\n\nTrue\n\n\n\n\n\n3.2.2 str\nStrings are sequences of characters. Strings literals are written by enclosing a sequence of characters in single or double quotes. Note that doubles quotes are preferred by the black code formatter, which is used in this book, but most Python environments will use single quotes by default when displaying strings.\n\n\"USD\"\n\n'USD'\n\n\nStrings are sequences of Unicode characters, which means they can represent any character in any language.\n\n\"Bitcoin  🚀\"\n\n'Bitcoin  🚀'\n\n\nString literals can span multiple lines by enclosing them in triple quotes or triple double quotes. This is useful for writing multiline strings.\n\n# Multiline strings\n\n\"\"\"GAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\"\"\"\n\n'GAFA is a group of companies:\\n\\n- Google\\n- Apple\\n- Facebook\\n- Amazon\\n\\n'\n\n\nMultiline strings, or any strings with special characters, can be displayed using the print function.\n\nprint(\n    \"\"\"GAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\"\"\"\n)\n\nGAFA is a group of companies:\n\n- Google\n- Apple\n- Facebook\n- Amazon\n\n\n\n\n\n\n3.2.3 bytes\nbytes are sequences of integers in the range of 0-255. They are often used for representing binary data or encoding text. Bytes literals are written by prepending a string literal with b.\n\nb\"Hello\"\n\nb'Hello'\n\n\n\n\n\n\n\n\nBytes vs strings\n\n\n\nBytes can be confused with strings, but they are not the same. Strings are sequences of Unicode characters, while bytes are sequences of integers in the range of 0-255. Bytes are often used for representing binary data or encoding text. In most cases, you will be working with strings, but you may encounter bytes when working with binary file formats or network communication."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#variables",
    "href": "introduction-to-python/python-basics/index.html#variables",
    "title": "3  Python Basics",
    "section": "3.3 Variables",
    "text": "3.3 Variables\nA variable in Python is a named location in the computer’s memory that holds a value. It serves as a container for data, allowing you to reference and manipulate the data stored within it. Variables are created by assigning a value to a name using the assignment operator (=). They can store data of various types, such as integers, floats, strings, or even more complex data structures like lists.\nUnderstanding the concept of variables and their naming conventions will help you write clean, readable, and maintainable code. An overview of variable naming rules in Python is presented in Table 3.2, and Table 3.3 presents some examples of valid and invalid variable names.\n\n\nTable 3.2: Variable naming rules\n\n\n\n\n\n\nRule\nDescription\n\n\n\n\nCan contain letters, numbers, and underscores\nVariable names can include any combination of letters (both uppercase and lowercase), numbers, and underscores (_). Python variable names support Unicode characters, enabling you to use non-English characters in your variable names. However, they must follow the other rules mentioned below.\n\n\nCannot start with a number\nAlthough variable names can contain numbers, they must not begin with a number. For example, 1_stock is an invalid variable name, whereas stock_1 is valid.\n\n\nCannot be a reserved word\nPython has a set of reserved words (e.g., if, else, while) that have special meanings within the language. You should not use these words as variable names.\n\n\n\n\n\n\nTable 3.3: Variable naming examples\n\n\nValid\nInvalid\n\n\n\n\nticker\n1ceo\n\n\nfirm_size\n@price\n\n\ntotal_sum_2023\nclass\n\n\n_tmp_buffer\nfor\n\n\n\n\n\n\n\n\n\n\nCase-sensitive\n\n\n\nPython is case-sensitive, so ret and RET are two different variables.\n\n\nBeyond the rules mentioned above, there are also some conventions that you should follow when naming variables. These conventions are not enforced by Python, but they are widely adopted by the Python community. Table 3.4 summarizes the most common conventions.\n\n\nTable 3.4: Variable naming conventions\n\n\n\n\n\n\nConvention\nDescription\n\n\n\n\nUse lowercase letters and underscores for variable names\nTo enhance code readability, use lowercase letters for variable names and separate words with underscores. For example, market_cap is a recommended variable name, whereas MarketCap or marketCap are not. This naming convention is known as snake case.\n\n\nUse uppercase letters for constants\nConstants are values that do not change throughout the program. Use uppercase letters and separate words with underscores to differentiate them from regular variables. For example, INFLATION_TARGET is a suitable constant name. Note that Python does not support constants like other languages, so this is just a convention, but Python won’t stop you from changing the value of a constant.\n\n\n\n\nBy adhering to these guidelines, you will improve your coding style and ensure that your code is easier to understand, maintain, and collaborate on with your peers.\n\n\n\n\n\n\nReserved keywords\n\n\n\nReserved keywords cannot be used as variable names. You can check the complete list of reserved keywords by running the following command in the Python console:\n\nhelp(\"keywords\")\n\n\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\nFalse               class               from                or\nNone                continue            global              pass\nTrue                def                 if                  raise\nand                 del                 import              return\nas                  elif                in                  try\nassert              else                is                  while\nasync               except              lambda              with\nawait               finally             nonlocal            yield\nbreak               for                 not                 \n\n\n\nNote that some reserved keywords may be confusing when thinking about finance problems. For example, return, yield, raise, global, class, and lambda are all reserved keywords, so you cannot use them as variable names. Most modern IDEs, such as Visual Studio Code, will highlight reserved keywords in a different color to help you avoid using them as variable names.\n\n\n\n3.3.1 Declaring variables\nA simple way to think about variables is to consider them labels that you can use to refer to values. For example, you can create a variable x and assign it a value of 42 using the assignment operator (=). You can then use the variable x to refer to the value 42 in your code.\n\nx = 42\nx\n\n42\n\n\n\n\n\n\n\n\nThe walrus operator\n\n\n\nIn the previous example, we added x to the last line of the code to display the value of x. This is necessary in the interactive window and in Jupyer Notebooks, as they automatically display the result of the last line of the code. However, the assignment operator (=) does not return a value, so the value of x is not displayed without that last line.\n\nx = 42\n\nIntroduced in Python 3.8, the := operator, also known as the walrus operator, allows you to assign a value to a variable and return that value in a single expression. For example, you can use the walrus operator to assign a value of 10 to a variable z and use that variable in the same expression, assigning the result to y.\n\ny = (z := 10) * 2\n\nNote, however, that the walrus operator cannot be used to assign a value to a variable without using it in an expression. For example, the following code will raise an error.\n\nx := 42\n\nSyntaxError: invalid syntax (4042238066.py, line 1)\n\n\n\n\nYou can reassign the value of a variable by assigning a new value to it. Once you reassign the value of a variable, the old value is lost. For example, you can reassign the value of x to 32 by running the following code.\n\nx = 32\nx\n\n32\n\n\nYou can perform operations on variables, just like you would on values. For example, you can add 10 to x.\n\nx + 10\n\n42\n\n\nYou can assign the result of an operation to a new variable. For example, you can assign the result of 2 * 10 to a new variable y.\n\ny = 2 * x\ny\n\n64\n\n\n\nz = x + y\nz\n\n96\n\n\nIf you try to use a variable name that is invalid, Python will raise an error. For example, if you try to assign a variable 1ceo, Python will raise an error because variable names cannot start with a number.\n\n1ceo = 2\n\nSyntaxError: invalid decimal literal (1479589190.py, line 1)\n\n\nYou can, however, use Unicode characters in variable names. For example, you can use accents such as é in a variable name.\n\ncote_de_crédit = \"AAA\"\n\nA leading underscore in a variable name indicates that the variable is private, which means that it should not be accessed outside of the module or scope in which it is defined. For example, you can use a leading underscore in a variable name to indicate that the variable is private. This is a convention that is widely adopted by the Python community, but it is not enforced by Python.\n\n_hidden = 30_000\n\nAnother convention is to use all caps for constants. For example, you can use all caps to indicate that INFLATION_TARGET is a constant.\n\nINFLATION_TARGET = 0.02\n\nPython will raise an error if you attempt to use a variable that has not been declared. For instance, if you try to use the variable inflation_target instead of INFLATION_TARGET, Python will generate an error. It’s important to note that Python is case-sensitive, so variables must be referenced with the exact casing as their declaration.\n\ninflation_target\n\nNameError: name 'inflation_target' is not defined\n\n\n\n\n3.3.2 Variable types\nPython is a dynamically typed language, meaning you do not need to specify the variable type when you declare it. Instead, Python will automatically infer the type of a variable based on the value you assign to it. For example, if you assign an integer value to a variable, Python will infer that the variable is an integer. Similarly, if you assign a string value to a variable, Python will infer that the variable is a string. You can use the type() function to check the type of a variable. For example, you can check the type of a by running the following code.\n\na = 3.3\ntype(a)\n\nfloat\n\n\n\nb = 2\ntype(b)\n\nint\n\n\n\nmarket_open = True\ntype(market_open)\n\nbool\n\n\n\ncurrency = \"CAD\"\ntype(currency)\n\nstr\n\n\n\n\n\n\n\n\nVariables explorer in Visual Studio Code\n\n\n\nVS Code has a built-in variable explorer that allows you to view the variables in your workspace when using the interactive window or a Jupyer Notebook. You can open the Variables View by clicking on the Variables button in the top toolbar of the editor:\n\n\n\nVariable View button\n\n\nThe Variables View will appear at the bottom of the window, showing the variables in your workspace, along with their values, types, and size for collections. For example, the following screenshot shows the variables in the workspace after running the code in this section:\n\n\n\nVariable View\n\n\n\n\n\n3.3.2.1 Converting between types\nYou can convert a variable from one type to another using the built-in functions float(), int(), str(), and bool(). For example, you can convert the variable x, which is currently an int, to a float by running the following code.\n\nfloat(x)\n\n32.0\n\n\nThe same way, you can convert the variable y, which is currently a float, to an int by running the following code. Note that the int() function will round down the value of y to the nearest integer.\n\nint(a)\n\n3\n\n\nSimilarly, you can convert the variable x to a string by running the following code.\n\nstr(x)\n\n'32'\n\n\nYou can convert a string to an integer or a float if the string contains a valid representation of a number. For example, you can convert the string \"42\" to an integer by running the following code.\n\nint('42')\n\n42\n\n\nHowever, you cannot convert a string that does not contain a valid representation of a number to an integer. For example, you cannot convert the string \"42.5\" to an integer.\n\nint('42.5')\n\nValueError: invalid literal for int() with base 10: '42.5'\n\n\nWhen converting to a boolean value, most values will be converted to True, except for 0, 0.0, and \"\", which will be converted to False.\n\nbool(0)\n\nFalse\n\n\n\nbool(1)\n\nTrue\n\n\n\nbool(\"\")\n\nFalse\n\n\n\nbool(\"33\")\n\nTrue\n\n\nThe None value is a special type in Python that represents the absence of a value. You can use the None value to initialize a variable without assigning it a value. For example, you can initialize a variable problem to None by running the following code.\n\nproblem = None\ntype(problem)\n\nNoneType"
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#comments",
    "href": "introduction-to-python/python-basics/index.html#comments",
    "title": "3  Python Basics",
    "section": "3.4 Comments",
    "text": "3.4 Comments\nComments are an essential part of writing clear, maintainable code. They help explain the purpose, logic, or any specific details of the code that might not be obvious at first glance. However, excessive or unnecessary commenting can clutter your code and make it harder to read. To strike the right balance, consider the guidelines listed in Table 3.5 when deciding when to use comments and when to avoid them:\n\n\nTable 3.5: Guidelines for comments\n\n\n\n\n\n\nGuideline\nDescription\n\n\n\n\nUse comments when the code is complex or non-obvious\nWhen your code involves complex algorithms, calculations, or logic that may be difficult for others (or yourself) to understand at a glance, use comments to explain the reasoning behind the code or to provide additional context.\n\n\nAvoid comments for simple or self-explanatory code\nFor code that is simple, clear, and easy to understand, avoid adding comments. Instead, use descriptive variable and function names that convey the purpose of the code.\n\n\nUse comments to explain the ‘why’, not the ‘how’\nGood comments explain the purpose of a piece of code or the reasoning behind a decision. Focus on providing context and insight that isn’t immediately apparent from reading the code. Avoid repeating what the code is doing, as this can be redundant and clutter the code.\n\n\nAvoid commenting out large blocks of code\nInstead of leaving large blocks of commented-out code in your final version, remove them. It’s better to use version control systems like Git to keep track of previous versions of your code.\n\n\nKeep comments up-to-date\nEnsure that your comments are always up-to-date with the code they describe. Outdated comments can be confusing and misleading, making it harder to understand the code.\n\n\nUse comments to provide additional information\nUse comments to provide references to external resources, such as links to relevant documentation, papers, or articles. This can be helpful for providing additional context or background information related to the code.\n\n\nUse consistent commenting style\nFollow a consistent commenting style throughout your codebase. This makes it easier for others to read and understand your comments.\n\n\n\n\n\n3.4.1 Writing comments\nIn Python, comments are created using the # symbol. Any text that follows the # symbol on the same line is ignored by the Python interpreter. Comments can be placed on a separate line or at the end of a line of code.:\n\n# This is a single-line comment\n\nprice = 150  # This is an inline comment\n\nYou can also create multi-line comments by enclosing the text in triple quotes (\"\"\" or '''). Multi-line comments are often used to provide docstrings (documentation strings) for functions and classes. We’ll learn more about functions and classes in a later section. Note that multi-line comments are technically strings, but the Python interpreter ignores them and does not store them in memory because they are not assigned to a variable.\n\n\"\"\"\nThis is a multi-line comment.\nYou can write your comments across multiple lines.\n\"\"\"\n\n'\\nThis is a multi-line comment.\\nYou can write your comments across multiple lines.\\n'\n\n\nComments can occur alongside code to document its purpose or explain the logic.\n\n# Calculate compound interest\nprincipal = 1000  # Principal amount\nrate = 0.05  # Annual interest rate\ntime = 5  # Time in years\n\n# Future value with compound interest formula\nfuture_value = principal * (1 + rate) ** time\n\n# Display the result\nprint(f\"Future value: {future_value:.2f}\")\n\nFuture value: 1276.28\n\n\n\n\n\n\n\n\nDon’t overdo it\n\n\n\nComments are useful for providing additional context or explanation, but they can also be overdone. Avoid adding comments for trivial or self-explanatory code. For example, the code above is simple and clear enough to understand without comments, so adding comments is decreasing readability instead of improving it.\n\n\nComments are usually written in English, but you can use any language as long as the file is UTF-8 encoded. You can also use emojis in comments if you like 😊."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#numbers",
    "href": "introduction-to-python/python-basics/index.html#numbers",
    "title": "3  Python Basics",
    "section": "3.5 Numbers",
    "text": "3.5 Numbers\nPython provides built-in functions and operators to perform mathematical operations on numbers. Some commonly used mathematical functions include abs(), round(), min(), max(), and pow(). Additionally, Python’s math library offers more advanced functions like trigonometry and logarithms.\n\n\n\n\n\n\nRounding errors\n\n\n\nFloating-point numbers may be subject to rounding errors due to the limitations of their binary representation. Keep this in mind when comparing or performing calculations with floats. Consider using the Decimal data type from Python’s decimal library to avoid floating-point inaccuracies when dealing with high-precision financial data.\n\n\n\n\n\n\n\n\nPerformance\n\n\n\nWhen working with large datasets or performing complex calculations, consider using third-party libraries like NumPy and pandas, which are covered in later chapters, for improved performance and additional functionality.\n\n\n\n3.5.1 Operations\nThe Python language supports many mathematical operations. Table 3.6 lists some of the most commonly used operators.\n\n\nTable 3.6: Basic Arithmetic Operations\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n+\nAddition\n1 + 2\n3\n\n\n-\nSubtraction\n1 - 2\n-1\n\n\n*\nMultiplication\n3 * 4\n12\n\n\n/\nDivision\n1 / 2\n0.5\n\n\n**\nExponentiation\n2 ** 3\n8\n\n\n//\nFloor division\n14 // 3\n4\n\n\n%\nModulo (remainder)\n14 % 3\n2\n\n\n\n\n\na = 5\nb = 3\n\nprint(f\"Addition: a + b = {a + b}\")\nprint(f\"Subtraction: a - b = {a - b}\")\nprint(f\"Multiplication: a * b = {a * b}\")\nprint(f\"Division: a / b = {a / b}\")\nprint(f\"Exponentiation: a ** b = {a ** b}\")\nprint(f\"Floor Division: a // b = {a // b}\")\nprint(f\"Modulo: a % b = {a % b}\")\n\nAddition: a + b = 8\nSubtraction: a - b = 2\nMultiplication: a * b = 15\nDivision: a / b = 1.6666666666666667\nExponentiation: a ** b = 125\nFloor Division: a // b = 1\nModulo: a % b = 2\n\n\n\n\n\n\n\n\nf-strings\n\n\n\nThe previous examples use a special type of strings called f-strings to format the output. f-strings are a convenient way to embed variables and expressions inside strings. They are denoted by the f prefix and curly braces ({}) containing the variable or expression to be evaluated.\nWe cover f-strings in more details in Section 3.7.2.\n\n\n\n\n3.5.2 Common mathematical functions\nTo round numbers, use the round() function. The round() function takes two arguments: the number to be rounded and the number of decimal places to round to. The number is rounded to the nearest integer if the second argument is omitted.\n\nrounded_num = round(5.67, 1)\n\nprint(rounded_num)\nprint(type(rounded_num))\n\n\nrounded_to_int = round(5.67)\n\nprint(rounded_to_int)\nprint(type(rounded_to_int))\n\n5.7\n&lt;class 'float'&gt;\n6\n&lt;class 'int'&gt;\n\n\nSome mathematical functions will require the use of the math module from the Python Standard Library. The standard library is a collection of modules included with every Python installation. You can use the functions and types in these modules by importing them into your code using the import statement.\nFor example, to calculate the square root of a number, you can use the sqrt() function from the math module:\n\n1import math\n\nmath.sqrt(25)\n\n\n1\n\nImports the math module, making its functions available in the current code.\n\n\n\n\n5.0\n\n\nThis is only one of the many functions in the math module. You can view the complete list of functions in the module documentation. The math module also contains constants like pi and e, which you can access using the dot notation.\n\nmath.pi\n\n3.141592653589793\n\n\n\n\n3.5.3 Random numbers\nIt is often useful to generate random numbers for simulations and other applications. Python’s random module provides functions for generating pseudo-random1 numbers from different distributions.\n\n\n\n\n\n\nPseudo-random number generator\n\n\n\nThe random module uses the Mersenne Twister algorithm to generate pseudo-random numbers. This algorithm is deterministic, meaning that given the same seed value, it will produce the same sequence of numbers every time. This is useful for debugging and testing but not for security purposes. If you need a cryptographically secure random number generator, use the secrets module instead.\n\n\nThe random.seed() function initializes the pseudo-random number generator. If you do not call this function, Python will automatically call it the first time you generate a random number. The random.seed() function takes an optional argument that can be used to set the seed value. This can be useful for debugging and testing, allowing you to generate the same sequence of random numbers every time. If you do not specify a seed, Python will use the system time as the seed value, so you will get a different sequence of random numbers every time.\n\nimport random\n\n1random.seed(42)\n\n\n1\n\nSets the seed value to 42. Why 42? Because it’s the answer to life, the universe, and everything.\n\n\n\n\nrandom.random() generates a random float between 0 and 1 (exclusive).\n\nrand_num = random.random()\n\nrand_num\n\n0.6394267984578837\n\n\nrandom.randint(a, b) generates a random integer between a and b (inclusive).\n\nrand_int = random.randint(1, 10)\n\nrand_int\n\n1\n\n\nrandom.uniform(a, b) generates a random float between a and b (exclusive).\n\nrand_float = random.uniform(0, 1)\n\nrand_float\n\n0.7415504997598329\n\n\nrandom.normalvariate(mu, sigma) generates a random float from a normal distribution with mean mu and standard deviation sigma.\n\nrand_norm = random.normalvariate(0, 1)\n\nrand_norm\n\n-0.508616386057752\n\n\nThe full list of functions in the random module can be found in the module documentation.\n\n\n3.5.4 Floats and decimals\nBecause of the way computers store numbers, floating-point numbers are not exact. This can lead to unexpected results when performing arithmetic operations on floats.\n\n2.33 + 4.44\n\n6.7700000000000005\n\n\nTo avoid this problem when exact results are needed, use the Decimal type from the decimal module to perform arithmetic operations on decimal numbers. You could import the module using import decimal but this would require you to prefix all the functions and types in the module with decimal. To avoid this, you can directly import the Decimal type from the decimal module using from decimal import Decimal.\n\n1from decimal import Decimal\n\nDecimal(\"2.33\") + Decimal(\"4.44\")\n\n\n1\n\nImports the Decimal type from the decimal module. You can now refer to the Decimal type directly without having to prefix it with decimal.\n\n\n\n\nDecimal('6.77')\n\n\n\n\n\n\n\n\nDecimals vs. floats\n\n\n\nUsing the Decimal type in Python provides precise decimal arithmetic and avoids rounding errors, making it suitable for financial and monetary calculations, while floats offer faster computation and are more memory-efficient but can introduce small inaccuracies due to limited precision and binary representation.\n\n\n\n\n3.5.5 Financial formulas\nMany financial calculations involve performing arithmetic operations on financial data. Here are two examples of common calculations in finance and how they can be implemented in Python.\n\n3.5.5.1 Calculating the present value of a future cash flow\nThe formula for calculating the present value of a future cash flow is:  PV = \\frac{FV_t}{(1 + r)^t},  where FV_t is the future value of the cash flow at time t, r is the discount rate, and t is the number of periods.\n\nfuture_value = 1000\ndiscount_rate = 0.05\nperiods = 5\n\npresent_value = future_value / (1 + discount_rate) ** periods\n\npresent_value\n\n783.5261664684588\n\n\n\n\n3.5.5.2 Calculating the future value of an annuity\nThe formula for calculating the future value of an annuity is:  FV = PMT \\frac{(1 + r)^t - 1}{r},  where PMT is the payment, r is the interest rate, and t is the number of periods.\nIt can be written in Python as:\n\npayment = 100\nrate = 0.05\nperiods = 5\n\nfuture_value_annuity = payment * ((1 + rate) ** periods - 1) / rate\n\nfuture_value_annuity\n\n552.5631250000007\n\n\n\n\n\n\n\n\nParentheses and operator precedence\n\n\n\nPython, just like mathematics, follows a specific order of operations when evaluating expressions. The complete list of precedence rules can be found in the Python documentation.\nWhen in doubt, use parentheses to make the order of operations explicit.\nFor arithmetic operations, the order of operations is as follows:\n\nExponents\nNegative (-)\nMultiplication and division\nAddition and subtraction"
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#sec-defining-functions",
    "href": "introduction-to-python/python-basics/index.html#sec-defining-functions",
    "title": "3  Python Basics",
    "section": "3.6 Defining functions",
    "text": "3.6 Defining functions\nFunctions are blocks of organized and reusable code that perform a specific action. They allow you to encapsulate a set of instructions, making your code modular and easier to maintain. Functions can take input parameters, perform operations on those inputs, and return a result.\nDefining a function in Python involves the following steps:\n\nUse the def keyword: Start by using the def keyword, followed by the function name and parentheses that enclose any input parameters.\nAdd input parameters: Specify any input parameters within the parentheses, separated by commas. These parameters allow you to pass values to the function, which it can then use in its calculations or operations.\nWrite the function body: After the parentheses, add a colon (:) and indent the following lines to create the function body. This block of code contains the instructions that the function will execute when called.\nReturn a result (optional): If your function produces a result, use the return statement to send the result back to the caller. If no return statement is specified, the function will return None by default.\n\n\n\n\n\n\n\nBest practices\n\n\n\nWhen defining functions, keep the following best practices in mind:\n\nChoose descriptive function names: Use meaningful names that reflect the purpose of the function, making your code more readable and easier to understand.\nKeep functions small and focused: Each function should have a single responsibility, making it easier to test, debug, and maintain.\n\n\n\nWe can define functions to perform a wide variety of tasks. For example, we can define a function to calculate the present value of a future cash flow:\n\n1def present_value(future_value, discount_rate, periods):\n2    return future_value / (1 + discount_rate) ** periods\n\n\n# Example usage:\nfuture_value = 1000\ndiscount_rate = 0.05\nperiods = 5\n3result = present_value(future_value, discount_rate, periods)\nprint(f\"Present value: {result:.2f}\")\n\n\n1\n\nDefines a function called present_value that takes three input parameters: future_value, discount_rate, and periods.\n\n2\n\nCalculates the present value of a future cash flow using the formula from the previous section and returns the result to the caller. The code in the function body is indented to indicate that it is part of the function.\n\n3\n\nCalls the present_value function with the specified input values and stores the returned value in a variable called result. When the function is called, the input values are passed to the function as arguments in the same order as the parameters were defined. The function body is then executed, and the result is returned to the caller.\n\n\n\n\nPresent value: 783.53\n\n\n\n\n\n\n\n\nIndentation\n\n\n\nIndentation refers to the spaces or tabs used at the beginning of a line to organize code. It helps Python understand the program’s structure and which lines of code are grouped together.\nThe Python language specification mandates the use of consistent indentation for code readability and proper execution. Indentation is typically achieved using four spaces per level. It plays a crucial role in determining the scope and hierarchy of statements within control structures, such as loops and conditional statements. For example, the statements that are part of a function body must be indented to indicate that they are part of the function. The Python interpreter knows that the function body ends when the indentation level returns to the previous level.\n\n\nWe will learn more about functions in Section 3.11."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#sec-strings",
    "href": "introduction-to-python/python-basics/index.html#sec-strings",
    "title": "3  Python Basics",
    "section": "3.7 Strings",
    "text": "3.7 Strings\nText data is often encountered in finance in the form of stock symbols, company names, descriptions, or financial reports. Understanding how to work with strings is essential for processing and manipulating text data effectively.\nStrings are sequences of characters, and they can be created using single quotes (' '), double quotes (\" \"), or triple quotes (''' ''' or \"\"\" \"\"\") for multi-line strings.\n\n\n\n\n\n\nSpecial characters\n\n\n\nSome characters have special meanings in Python strings. The backslash (\\) is used to escape characters that have special meaning, such as newline (\\n) or tab (\\t). To include a backslash in a string, you need to escape it by adding another backslash before it (\\\\). Alternatively, you can use raw strings by prefixing the strings with r or R, which will treat backslashes as literal characters. For example, these two strings are equivalent:\nstr1 = \"C:\\\\Users\\\\John\"\nstr2 = r\"C:\\Users\\John\"\n\n\n\n3.7.1 String operations\nThe Python language provides many common string operations. Table 3.7 lists some of the most commonly used operations.\n\n\nTable 3.7: Common string operations\n\n\n\n\n\n\n\nOperation\nExample\nDescription\n\n\n\n\nConcatenate strings\nresult = str1 + \" \" + str2\nCombines two or more strings together\n\n\nRepeat strings\nresult = repeat_str * 3\nRepeats a string a specified number of times\n\n\nLength of a string\nlength = len(text)\nGets the length (number of characters) of a string\n\n\nAccess characters in a string\nfirst_char = text[0]\nRetrieves a specific character in a string\n\n\nSlice a string\nslice_text = text[0:12]\nExtracts a part of a string\n\n\nConvert case\nupper_text = text.upper()\nConverts a string to uppercase\n\n\n\nlower_text = text.lower()\nConverts a string to lowercase\n\n\nJoin a list of strings\ntext = \", \".join(companies)\nJoins a list of strings using a delimiter\n\n\nSplit a string\ncompanies = text.split(\", \")\nSplits a string into a list based on a delimiter\n\n\nReplace a substring\nnew_text = text.replace(\"Finance\", \"Python\")\nReplaces a specified substring in a string\n\n\nCheck substring existence\nresult = substring in text\nChecks if a substring exists in a string\n\n\n\n\nWe can concatenate (combine) two or more strings into a single string using the + operator.\n\nstr1 = \"Hello\"\nstr2 = \"World\"\nresult = str1 + \" \" + str2\nprint(result)\n\nHello World\n\n\nThe * operator repeats a string multiple times.\n\nrepeat_str = \"Python \"\nresult = repeat_str * 3\nprint(result)\n\nPython Python Python \n\n\nThe len() function returns the string’s length (number of characters).\n\ntext = \"Finance\"\nlength = len(text)\nprint(length)\n\n7\n\n\nSingle characters in a string can be accessed using the index of the character within square brackets ([]). Python uses zero-based indexing, so the first character in a string has index 0, the second character has index 1, and so on. You can also use negative indices to access characters from the end of a string, with the last character having index -1, the second last character having index -2, and so on.\n\ntext = \"Python\"\nfirst_char = text[0]\nlast_char = text[-1]\nprint(first_char)\nprint(last_char)\n\nP\nn\n\n\nExtracting a portion of a string by specifying a start and end index is called slicing. In Python, you can slice a string using the following syntax: text[start:end]. The start index is inclusive, while the end index is exclusive. If the start index is omitted, it defaults to 0. If the end index is omitted, it defaults to the length of the string.\n\ntext = \"empirical finance Python\"\nslice_text = text[0:7]\nprint(slice_text)\n\nempiric\n\n\nThe upper() and lower() methods convert a string to uppercase or lowercase, respectively.\n\ntext = \"Finance\"\nupper_text = text.upper()\nlower_text = text.lower()\nprint(upper_text)\nprint(lower_text)\n\nFINANCE\nfinance\n\n\n\n\n\n\n\n\nMethods vs functions\n\n\n\nA method is similar to a function but associated with a specific object or data type. In this case, upper() and lower() are methods specific to the str (string) data type. When we call the upper method on the text object using the dot notation (text.upper()), Python knows to transform the string stored in the text variable. Methods are particularly useful because they allow us to perform actions or operations specific to the object or data type they belong to, and they improve code readability by making it clear what object the method is being called on.\n\n\nThe join() method joins a list of strings into a single string using a delimiter. The delimiter can be specified as an argument to the join() method. Lists are introduced in the next section.\n\ncompanies = [\"Apple\", \"Microsoft\", \"Google\"]\ntext = \" | \".join(companies)\nprint(text)\n\nApple | Microsoft | Google\n\n\nThe split() method splits a string into a list of substrings based on a delimiter. The delimiter can be specified as an argument to the split() method. If no delimiter is specified, the string is split on whitespace characters.\n\ntext = \"Apple, Microsoft, Google\"\ncompanies = text.split(\", \")\nprint(companies)\n\n['Apple', 'Microsoft', 'Google']\n\n\nThe replace() method replaces a substring in a string with another string. It takes two arguments: the substring to replace and the string to replace it with.\n\ntext = \"Introduction to Finance\"\nnew_text = text.replace(\"Finance\", \"Python\")\nprint(new_text)\n\nIntroduction to Python\n\n\nThe in operator checks if a substring exists in a string. It returns a boolean value, True if the substring exists in the string, and False otherwise.\n\ntext = \"Introduction to Python\"\nsubstring = \"Python\"\nresult = substring in text\nprint(result)\n\nTrue\n\n\nThe Python documentation provides a complete list of string methods that you can refer to for more details.\n\n\n3.7.2 Formatting strings\nYou will often encounter situations where you must present or display data in a formatted, human-readable manner. F-strings are a powerful tool for formatting strings and embedding expressions or variables directly within the string. They provide a concise and easy-to-read way of formatting strings, making them an essential tool for working with text data.\nF-strings, also known as “formatted string literals,” allow you to embed expressions, variables, or even basic arithmetic directly into a string by enclosing them in curly braces {} within the string. The expressions inside the curly braces are evaluated at runtime and then formatted according to the specified format options.\nSome key features of f-strings that are useful include:\n\nExpression Evaluation: You can embed any valid Python expression within the curly braces, including variables, arithmetic operations, or function calls. This feature enables you to generate formatted strings based on your data dynamically.\nFormatting Options: F-strings support various formatting options, such as alignment, width, precision, and thousand separators. These options can be specified within the curly braces after the expression, separated by a colon (:).\nFormat Specifiers: You can use format specifiers to control the display of numbers, such as specifying the number of decimal places, using scientific notation, or adding a percentage sign. Format specifiers are especially useful in finance when working with currency, percentages, or large numbers.\n\nTo create an f-string, prefix the string with an f character, followed by single or double quotes. You can then embed expressions or variables within the string by enclosing them in curly braces ({}). For example, this lets you concatenate strings and variables together in a single statement:\n\nticker = \"AAPL\"\nexchange = \"NASDAQ\"\ncompany_name = \"Apple, Inc.\"\nfull_name = f\"{company_name} ({exchange}:{ticker})\"\nprint(full_name)\n\nApple, Inc. (NASDAQ:AAPL)\n\n\nPython will convert the expression within the curly braces to a string, which can be used to convert numbers to strings.\n\nnum = 42\nnum_str = f\"{num}\"\nprint(num_str)\n\n42\n\n\nPython evaluates the expression within the curly braces at runtime and then formats the string according to the specified format options. For example, you can use the :,.2f format option to display a number with a thousand separator and two decimal places.\n\namount = 12345.6789\nformatted_amount = f\"${amount:,.2f}\"\nprint(formatted_amount) \n\n$12,345.68\n\n\nYou can also use the :.2% format option to display a number as a percentage with two decimal places.\n\nrate = 0.05\nformatted_rate = f\"{rate:.2%}\"\nprint(formatted_rate) \n\n5.00%\n\n\nThe datetime module provides a datetime class to represent dates and times. The datetime class has a now() method that returns the current date and time. You can use the :%Y-%m-%d format option to display the date in YYYY-MM-DD format.\n\nfrom datetime import datetime\n\ncurrent_date = datetime.now()\nformatted_date = f\"{current_date:%Y-%m-%d}\"\nprint(formatted_date)\n\n2023-08-25\n\n\nYou can also use f-strings to align text to the left (&lt;), right (&gt;), or center (^) within a fixed-width column:\n\nticker = \"AAPL\"\nprice = 150.25\nchange = -1.25\n\n1formatted_string = f\"|{ticker:&lt;10}|{price:^10.2f}|{change:&gt;10.2f}|\"\nprint(formatted_string)\n\n\n1\n\nThe :&lt;10 format option aligns the text to the left within a 10-character column. The :^10.2f format option aligns the number to the center within a 10-character column and displays it with two decimal places. The :&gt;10.2f format option aligns the number to the right within a 10-character column and displays it with two decimal places.\n\n\n\n\n|AAPL      |  150.25  |     -1.25|\n\n\nMultiline f-strings work the same way as multiline strings, except that they are prefixed with an f character. You can use multiline f-strings to create formatted strings that span multiple lines.\n\nstock = \"AAPL\"\nprice = 150.25\nchange = -1.25\n\nformatted_string = f\"\"\"\nStock:  \\t{stock}\nPrice:  \\t${price:.2f}\nChange: \\t${change:.2f}\n\"\"\"\nprint(formatted_string)\n\n\nStock:      AAPL\nPrice:      $150.25\nChange:     $-1.25\n\n\n\n\n\n\n\n\n\nAlternative formatting methods\n\n\n\nWhen reading code or answers on websites such as Stack Overflow or receiving suggestions from AI-assisted coding assistant, you may encounter other string formatting methods. Before f-strings, the two primary string formatting methods in Python were %-formatting and str.format().\n%-formatting\nAlso known as printf-style formatting, %-formatting uses the % operator to replace placeholders with values. Inspired by the printf function in C, it has been available since early versions of Python. It is less readable and more error-prone than other methods.\nExample:\nformatted_string = \"%s has a balance of $%.2f\" % (name, balance)\nstr.format()\nThe str.format() method embeds placeholders using curly braces {} and replaces them with the format() method. Introduced in Python 2.6, it offers improved readability and more advanced formatting options compared to %-formatting.\nExample:\nformatted_string = \"{} has a balance of ${:,.2f}\".format(name, balance)\nAdvantages of f-strings\nI recommend using f-strings instead of %-formatting or str.format() for string formatting for the following reasons:\n\nReadability: Concise syntax with expressions and variables embedded directly.\nFlexibility: Supports any valid Python expression within curly braces.\nPerformance: Faster than other methods, evaluated at runtime.\nSimplicity: No need to specify variable order or maintain separate lists."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#sec-collections",
    "href": "introduction-to-python/python-basics/index.html#sec-collections",
    "title": "3  Python Basics",
    "section": "3.8 Collections",
    "text": "3.8 Collections\nSequences and collections are fundamental data structures in Python that allow you to store and manipulate multiple elements in an organized manner. They differ along three dimensions: order, mutability, and indexability. An ordered collection is one where the elements are stored in a particular order, the order of the elements is important, and you can iterate over the elements in that order. A collection is mutable if you can add, remove, or modify elements, after it is created. A collection is indexable if you can refer to its elements by their index (position or key).\nTable 3.8 presents the main types of sequences and collections in Python. You are already familiar with the string type, an ordered, immutable, and indexable sequence of characters.\n\n\nTable 3.8: Sequences and collections in Python\n\n\n\n\n\n\n\n\nName\nType\nDescription\nExample\n\n\n\n\nList\nlist\nOrdered, mutable, and indexed. Allows duplicate members.\n[1, 2, 3]\n\n\nTuple\ntuple\nOrdered, immutable, and indexed. Allows duplicate members.\n(1, 2, 3)\n\n\nSet\nset\nUnordered, mutable, and unindexed. No duplicate members.\n{1, 2, 3}\n\n\nDictionary\ndict\nUnordered, mutable, and indexed. No duplicate index entries. Elements are indexed according to a key.\n{\"a\": 1, \"b\": 4}\n\n\nString\nstring\nOrdered, immutable, and indexed. Allows duplicate characters.\n\"abc\"\n\n\n\n\n\n3.8.1 Lists\nLists in Python are ordered collections of items that can hold different data types. They are mutable, meaning that elements can be added, removed, or modified. Lists are versatile and commonly used to store and manipulate sets of related data. The elements within a list are accessed using indexes, which allow for easy retrieval and modification. Lists also support various built-in methods and operations for efficient data manipulation, such as appending, extending, sorting, and slicing.\nA list is created by enclosing a comma-separated sequence of elements within square brackets ([ ]). The elements can be of any data type, including other lists. The following code snippet creates a list of strings and a list of integers.\n\nstocks = [\"AAPL\", \"GOOG\", \"MSFT\"]\nprices = [150.25, 1200.50, 250.00]\n\nYou can access the elements of a list using their index. The index of the first element is 0, the index of the second element is 1, and so on. You can also use negative indexes to access elements from the end of the list. The index of the last element is -1, the index of the second to last element is -2, and so on. The following code snippet illustrates how to access the elements of the stocks and prices lists.\n\nfirst_stock = stocks[0]\nprint(first_stock)\n\nlast_price = prices[-1]\nprint(last_price)\n\nAAPL\n250.0\n\n\nYou can replace the elements of a list by assigning new values to their indexes, add new elements to the list using the append() method, or delete elements from the list using the remove() method.\n\n# Replace an element\nstocks[1] = \"GOOGL\"\nprint(stocks)\n\n# Adding an element to the list\nstocks.append(\"AMZN\")\nprint(stocks)\n\n# Removing an element from the list\nstocks.remove(\"MSFT\")\nprint(stocks)\n\n['AAPL', 'GOOGL', 'MSFT']\n['AAPL', 'GOOGL', 'MSFT', 'AMZN']\n['AAPL', 'GOOGL', 'AMZN']\n\n\nYou can also use the len() function to get the length of a list, and the in operator to check if an element is present in a list.\n\n# Length of the list\nlist_length = len(stocks)\nprint(f\"Length: {list_length}\")\n\n# Checking if an element is in the list\nis_present = \"AAPL\" in stocks\nprint(f\"Is AAPL in the list? {is_present}\")\n\nLength: 3\nIs AAPL in the list? True\n\n\n\n\n3.8.2 Tuples\nTuples are ordered collections of elements that are immutable, meaning they cannot be modified after creation. They are typically used to store related pieces of data as a single entity, and their immutability provides benefits such as ensuring data integrity and enabling safe data sharing across different parts of a program.\n\n\n\n\n\n\nTuples vs lists\n\n\n\nTuples and lists in Python differ in mutability, syntax, and use cases. Tuples are commonly used for fixed data, have a slight performance advantage over lists and can be more memory-efficient. Lists are commonly used for variable data, and provide more flexibility in terms of operations and methods.\n\n\nA tuple is created by enclosing a comma-separated sequence of elements within parentheses (( )). The elements can be of any data type, including other tuples. The following code snippet creates a tuple of integers and a tuple of strings.\n\nmu = 0.1\nsigma = 0.2\ntheta = 0.5\n\nparameters = (mu, sigma, theta)\nprint(parameters)\n\n(0.1, 0.2, 0.5)\n\n\nYou can access the elements of a tuple using their index, find their length using len(), just like with lists.\n\n# Accessing elements in a tuple\nsigma0 = parameters[1]\nprint(sigma0)\n\n# Length of the tuple\ntuple_length = len(parameters)\nprint(f\"Length: {tuple_length}\")\n\n0.2\nLength: 3\n\n\nTuples are immutable, so you cannot add, remove, or replace their elements directly. You can, however, create a new tuple with the modified elements. Also note that you can modify mutable elements within a tuple, such as a list.\n\na = [1, 2, 3]\nb = (\"c\", a, 2)\nprint(f\"Before appending to list a: {b}\")\n\na.append(4)\nprint(f\"After appending to list a: {b}\")\n\nBefore appending to list a: ('c', [1, 2, 3], 2)\nAfter appending to list a: ('c', [1, 2, 3, 4], 2)\n\n\nb still contains the same elements, but the list a within the tuple has been modified.\n\n3.8.2.1 Tuple unpacking\nTuple unpacking is a powerful feature of Python that allows you to assign multiple variables from the elements of a tuple in a single line of code. It is a form of “destructuring assignment” that provides a concise way to extract the elements of a tuple into individual variables.\nTo perform tuple unpacking, you use a sequence of variables on the left side of an assignment statement, followed by a tuple on the right side. When the assignment is made, each variable on the left side will be assigned the corresponding value from the tuple on the right side.\nHere is an example:\n\n# Create a tuple\nt = (1, 2, 3)\n\n# Unpack the tuple into three variables\na, b, c = t\n\n# Display the values of the variables\nprint(f\"a: {a}, b: {b}, c: {c}\")\n\na: 1, b: 2, c: 3\n\n\nIn this example, the tuple t contains three elements: 1, 2, and 3. When the tuple is unpacked into the variables a, b, and c, each variable gets assigned the corresponding value from the tuple: a gets 1, b gets 2, and c gets 3.\nTuple unpacking can be useful in various situations. For example, when working with functions that return multiple values as a tuple, you can use tuple unpacking to assign the return values to individual variables. Here’s an example:\n\n# Define a function that returns a tuple\ndef get_top3_stocks():\n    return (\"AAPL\", \"MSFT\", \"AMZN\")\n\n# Unpack the returned tuple into three variables\nstock1, stock2, stock3 = get_top3_stocks()\n\n# Display the values of the variables\nprint(f\"Largest: {stock1}, 1nd: {stock2}, 3rd: {stock3}\")\n\nLargest: AAPL, 1nd: MSFT, 3rd: AMZN\n\n\nNote that the number of variables on the left side of the assignment must match the number of elements in the tuple being unpacked.\n\n\n\n3.8.3 Sets\nSets are unordered collections of unique elements. They are defined using curly braces { } or the set() constructor. Sets do not allow duplicate values and support various operations such as intersection, union, and difference. Sets are commonly used for tasks like removing duplicates from a list, membership testing, and mathematical operations on distinct elements.\n\n# Creating a set\nunique_numbers = {1, 2, 3, 2, 1}\nprint(unique_numbers)\n\n# Adding an element to the set\nunique_numbers.add(4)\nprint(f\"Added 4: {unique_numbers}\")\n\n# Removing an element from the set\nunique_numbers.remove(1)\nprint(f\"Removed 1: {unique_numbers}\")\n\n# Checking if an element is in the set\nis_present = 2 in unique_numbers\nprint(f\"Is 2 in the set? {is_present}\")\n\n# Length of the set\nset_length = len(unique_numbers)\nprint(f\"Length: {set_length}\")\n\n{1, 2, 3}\nAdded 4: {1, 2, 3, 4}\nRemoved 1: {2, 3, 4}\nIs 2 in the set? True\nLength: 3\n\n\nSets support operations such as intersection, union, and difference, which are performed using the &, |, and - operators respectively.\n\nset1 = {1, 2, 3, 4}\nset2 = set([3, 4, 5, 6])\n\n# Intersection\nprint(f\"Intersection: {set1 & set2}\")\n\n# Union\nprint(f\"Union: {set1 | set2}\")\n\n# Difference\nprint(f\"Difference: {set1 - set2}\")\n\nIntersection: {3, 4}\nUnion: {1, 2, 3, 4, 5, 6}\nDifference: {1, 2}\n\n\n\n\n\n\n\n\nSets and data types\n\n\n\nSets can contain elements of different data types, including numbers, strings, and tuples. However, sets only support immutable elements, so you cannot add lists or dictionaries to a set.\n\n\n\n\n3.8.4 Dictionaries\nDictionaries are key-value pairs that provide a way to store and retrieve data using unique keys. They are defined with curly braces { } like sets, but contain pairs of elements called items, where each item is a key-value pair separated by a colon (:).\nDictionaries are unordered and mutable, allowing for efficient data lookup and modification. They are commonly used for mapping and associating values with specific keys, making them useful for tasks like storing settings, organizing data, or building lookup tables.\n\nstock_prices = {\"AAPL\": 150.25, \"GOOGL\": 1200.50, \"MSFT\": 250.00}\nprint(stock_prices)\n\n{'AAPL': 150.25, 'GOOGL': 1200.5, 'MSFT': 250.0}\n\n\nYou access the value for a specific key using square brackets [ ], and modify the value for a key using the assignment operator =. You add new key-value pairs to a dictionary using a new key and assignment operator and remove a key-value pair using the del keyword. The len() function returns the number of key-value pairs in a dictionary.\n\n# Accessing elements in a dictionary\nprice_aapl = stock_prices[\"AAPL\"]\nprint(f\"Price for AAPL: {price_aapl:0.2f}\")\n\n# Modifying an element\nstock_prices[\"GOOGL\"] = 1205.00\nprint(f\"Modified GOOGL: {stock_prices}\")\n\n# Adding a new element to the dictionary\nstock_prices[\"AMZN\"] = 3300.00\nprint(f\"Added AMZN: {stock_prices}\")\n\n# Removing an element from the dictionary\ndel stock_prices[\"MSFT\"]\nprint(f\"Removed MSFT: {stock_prices}\")\n\n# Length of the dictionary\ndict_length = len(stock_prices)\nprint(f\"Length: {dict_length}\")\n\nPrice for AAPL: 150.25\nModified GOOGL: {'AAPL': 150.25, 'GOOGL': 1205.0, 'MSFT': 250.0}\nAdded AMZN: {'AAPL': 150.25, 'GOOGL': 1205.0, 'MSFT': 250.0, 'AMZN': 3300.0}\nRemoved MSFT: {'AAPL': 150.25, 'GOOGL': 1205.0, 'AMZN': 3300.0}\nLength: 3\n\n\nThe collection module from Python’s standard library provides many other data structures such as defaultdict, OrderedDict, Counter, and deque. You can learn more about these data structures in the Python documentation."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#comparison-operators-and-branching",
    "href": "introduction-to-python/python-basics/index.html#comparison-operators-and-branching",
    "title": "3  Python Basics",
    "section": "3.9 Comparison operators and branching",
    "text": "3.9 Comparison operators and branching\n\n3.9.1 Comparison operators\nPython provides several comparison operators that allow you to compare values and evaluate expressions. Comparison operators can be used with various data types, such as numbers, strings, or even complex data structures, and return a boolean value (True or False). Table 3.9 lists the comparison operators available in Python.\n\n\nTable 3.9: Comparison operators in Python\n\n\nOperator\nName\nExample\nResult\n\n\n\n\n==\nEqual\n1 == 2\nFalse\n\n\n!=\nNot equal\n1 != 2\nTrue\n\n\n&gt;\nGreater than\n1 &gt; 2\nFalse\n\n\n&lt;\nLess than\n1 &lt; 2\nTrue\n\n\n&gt;=\nGreater or equal\n1 &gt;= 2\nFalse\n\n\n&lt;=\nLess or equal\n1 &lt;= 2\nTrue\n\n\nin\nMembership\n1 in [1, 2, 3]\nTrue\n\n\nis\nIdentity comparison\n1 is None\nFalse\n\n\n\n\nTo create more complex conditions, you can chain multiple comparisons in a single expression using logical operators like and, or, or not. The result of a logical operator is a boolean value (True or False). Table 3.10 lists the logical operators available in Python.\n\n\nTable 3.10: Logical operators in Python\n\n\na\nb\na and b\na or b\nnot a\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\nTrue\nFalse\n\n\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n\n\n\n\n\n\n\n\n& and | are bitwise operators, not logical operators\n\n\n\nPython also provides bitwise operators that perform bitwise operations on integers. These operators are & (bitwise AND), | (bitwise OR), ^ (bitwise XOR), ~ (bitwise NOT), &lt;&lt; (bitwise left shift), and &gt;&gt; (bitwise right shift). Most casual Python users will not need to use these operators, but they can be confusing for new users due to their similar syntax to logical operators in other programming languages. To add to the confusion, popular Python libraries like NumPy and Pandas overload the bitwise operators to perform logical operations on arrays.\nIt is crucial for beginners to understand the distinction between logical and bitwise operators and to use the appropriate operators (which are usually and, or, or not) based on their intended purpose to ensure the desired logical evaluations are achieved.\n\n\nLonger expressions can be grouped using parentheses to ensure the desired order of operations. For example, a and b or c is equivalent to (a and b) or c, whereas a and (b or c) is different. Python does not offer a built-in exclusive or (XOR) operator, but it can be achieved using a combination of other operators.\n\ndef xor(a, b):\n    return (a and not b) or (not a and b)\n\n\nprint(f\"xor(True, True)) = {xor(True, True)}\")\nprint(f\"xor(True, False)) = {xor(True, False)}\")\nprint(f\"xor(False, True)) = {xor(False, True)}\")\nprint(f\"xor(False, False)) = {xor(False, False)}\")\n\nxor(True, True)) = False\nxor(True, False)) = True\nxor(False, True)) = True\nxor(False, False)) = False\n\n\n\n\n3.9.2 Branching\nBranching allows your code to execute different actions based on specific conditions. The primary branching construct in Python is the if statement, which can be combined with elif (short for “else if”) and else clauses to create more complex decision-making structures.\nLike other compound statements in Python, the if statement uses indentation to group statements together. The general syntax for an if statement is to start with the if keyword followed by a condition, then a colon (:), and, finally, an indented block of code that will be executed if the condition evaluates to True. The elif and else clauses are optional and can be used to specify additional conditions and code blocks to execute if the initial condition evaluates to False. The elif clause is used to chain multiple conditions together, whereas the else clause is used to specify a default code block to execute if none of the previous conditions evaluate to True.\n\nprice = 150\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\n\nThe stock price is high.\n\n\nIn the previous example, the code block is executed because the price = 150, therefore the condition price &gt; 100 evaluates to True.\nWe can add an else clause to specify a default code block to execute if the condition evaluates to False.\n\nprice = 50\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\nelse:\n    print(\"The stock price is low.\")\n\nThe stock price is low.\n\n\nWe can add an elif clause to specify additional conditions to evaluate if the initial condition evaluates to False. The elif clause can be used multiple times to chain multiple conditions together. The elif clause is optional, but if it is used, it must come before the else clause. The else clause is also optional, but if it is used, it must come last.\nIn all cases, the code block associated with the first condition that evaluates to True will be executed, and the remaining conditions will be skipped. If none of the conditions evaluate to True, then the code block associated with the else clause will be executed. If there is no else clause, then nothing will be executed.\n\nprice = 75\n\nif price &gt; 100:\n    print(\"The stock price is high.\")\nelif price &gt; 50:\n    print(\"The stock price is moderate.\")\nelse:\n    print(\"The stock price is low.\")\n\nThe stock price is moderate.\n\n\nYou can nest if statements inside other if statements to create more complex branching structures. The code block associated with the nested if statement must be indented further than the outer if statement. The nested if statement will only be evaluated if the condition associated with the outer if statement evaluates to True. When reading nested if statements, it is helpful to read from the top down and to keep track of the indentation level to understand which code blocks are associated with which conditions.\n\nprice = 150\nvolume = 1000000\n\nif price &gt; 100:\n    if volume &gt; 500000:\n        print(\"The stock price is high and has high volume.\")\n    else:\n        print(\"The stock price is high but has low volume.\")\nelse:\n    print(\"The stock price is not high.\")\n\nThe stock price is high and has high volume.\n\n\nConditions can be combined using the logical operators and, or, and not to create more complex conditions.\n\nprice = 150\nvolume = 1000000\n\nif price &gt; 100 and volume &gt; 500000:\n    print(\"The stock price is high and has high volume.\")\nelif price &gt; 100 or volume &gt; 500000:\n    print(\"The stock price is high or has high volume.\")\nelse:\n    print(\"The stock price is not high and has low volume.\")\n\nThe stock price is high and has high volume.\n\n\n\n\n3.9.3 Conditional assignment\nPython provides a convenient shorthand for assigning a value to a variable based on a condition. This is known as conditional assignment. The syntax for conditional assignment is variable = value1 if condition else value2. If the condition evaluates to True, the variable is assigned value1; otherwise, it is assigned value2.\n\nprice = 150\n\nmessage = \"The stock price is high.\" if price &gt; 100 else \"The stock price is low.\"\nprint(message)\n\nThe stock price is high."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#typing",
    "href": "introduction-to-python/python-basics/index.html#typing",
    "title": "3  Python Basics",
    "section": "3.10 Typing",
    "text": "3.10 Typing\nPython is a dynamically typed language. This means that you don’t have to specify the type of a variable when you define it. The Python interpreter will automatically infer the type based on the value assigned to the variable.\nPython also supports optional type annotations, also called type hints, since version 3.5. This allows you to specify the types of variables, function arguments, and return values to improve code readability and catch potential errors early. The Python interpreter will ignore the type annotations and run the code normally. However, you can use external tools like mypy to analyze the code and check for type errors, and modern IDEs like VS Code provide built-in support for type checking.\n\nticker: str = \"AAPL\"\n\n\nstock_prices: list[float] = [150.25, 1200.50, 250.00]\n\n\n# Old version, not needed since Python 3.9\n\nfrom typing import List\n\nstock_prices: List[float] = [150.25, 1200.50, 250.00]\n\n\n# You can also specify function parameters and return types:\n\n\ndef calculate_profit(revenue: float, expenses: float) -&gt; float:\n    return revenue - expenses\n\n\nrevenue = 1000.00\nexpenses = 500.00\nprofit = calculate_profit(revenue, expenses)\n\n\n\n\n\n\n\nType hints in Visual Studio Code\n\n\n\nType hints are not required to run Python code, but they can be very useful to improve code readability and catch potential errors early. Modern IDEs like VS Code provide built-in support for type checking that you can enable.\nI find this quite overwhelming, so I prefer to enable type-checking only when needed. However, VS Code still uses type hints to provide useful features like hover info.\n\n\n\nTooltip when hovering over variable.\n\n\n\n\n\nTooltip when hovering over function.\n\n\n\n\nThe typing module provides a set of special types that can be used in type hints. Here are some of the most commonly used ones:\n\nAny: Any type\nOptional: An optional value (can be None)\nCallable: A function\nIterable: An iterable object (e.g., list, tuple, set)"
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#sec-functions-parameters-return-values",
    "href": "introduction-to-python/python-basics/index.html#sec-functions-parameters-return-values",
    "title": "3  Python Basics",
    "section": "3.11 Functions: parameters and return values",
    "text": "3.11 Functions: parameters and return values\nFunctions help you organize and structure your code by encapsulating specific tasks or calculations. They allow you to define input parameters, perform operations, and return the results, making your code more flexible and maintainable. We have already written simple functions in Section 3.6; we will now look in more detail at how to define parameters and return values.\n\n\n\n\n\n\nType hints in examples\n\n\n\nIn the examples below, I use type hints to indicate the type of the function parameters and return values. Type hints are not required to run Python code, but using them is a good practice as they provide helpful information to other developers (including your future self!) and tools such as linters and type checkers.\n\n\n\n3.11.1 Parameters\nParameters are variables defined within the function signature, enabling you to pass input values to the function when it is called. Parameters can have a default value assigned to them when no value is provided during the function call. Default values can make your functions more flexible and easy to use. Using the *args and **kwargs syntax, you can pass a variable number of positional or keyword arguments to a function, providing greater flexibility for handling different input scenarios.2\n\n\n\n\n\n\nParameter vs. argument\n\n\n\nThe terms function parameter and argument refer to different concepts related to functions.\nFunction parameter: A function parameter is a variable defined in the function’s definition or signature. It represents a value that the function expects to receive when it is called. Parameters act as placeholders for the actual values that will be passed as arguments when the function is invoked.\nArgument: An argument is the actual value that is passed to a function when it is called. It corresponds to a specific function parameter and provides the actual data or input that the function operates on. Arguments are supplied in the function call, within parentheses, and are passed to the corresponding function parameters based on their position or using keyword arguments.\n\n\n\ndef calculate_roi(investment: float, profit: float) -&gt; float:\n    return (profit / investment) * 100.0\n\n\ninvestment = 2000.00\nprofit = 500.00\nroi = calculate_roi(investment, profit)\nprint(roi)\n\n25.0\n\n\nIn the previous example, variables investment and profit are passed to the function calculate_roi() in the same order as they are defined in the function definition. This is called positional arguments. The names of the variables do not matter, only the order in which they are passed to the function. If we invert the order of the variables, the result will be different.\n\nbad_roi = calculate_roi(profit, investment)\nprint(bad_roi)\n\n400.0\n\n\nPositional arguments can be confusing when the function has many parameters or when the order of the arguments is not obvious. To avoid this, you can use keyword arguments.\n\nroi1 = calculate_roi(investment=2000.00, profit=500.00)\nprint(roi1)\n\nroi2 = calculate_roi(profit=500.00, investment=2000.00)\nprint(roi2)\n\nroi3 = calculate_roi(profit=profit, investment=investment)\nprint(roi3)\n\n25.0\n25.0\n25.0\n\n\nNote that the name of the original variables does not matter, only the name of the parameters in the function definition. In the last example, we use the same names for the variables and the parameters, but the Python interpreter does not care about that. The following code is equivalent to the previous one:\n\nx = 2000.00\ny = 500.00\n\nroi4 = calculate_roi(profit=y, investment=x)\nprint(roi4)\n\n25.0\n\n\nYou can also mix positional and keyword arguments. However, positional arguments must always come before keyword arguments.\n\nroi4 = calculate_roi(investment, profit=profit)\nprint(roi4)\n\n25.0\n\n\nDefault parameters are useful when you want to provide a default value for a parameter, which is used when no value is provided during the function call. This makes your functions more flexible and easy to use, as you can omit parameters that have a default value.\nTo define a default parameter, assign a value to the parameter in the function definition using =. When the function is called, the default value will be used if no value is provided for that parameter. If a value is provided, it will override the default value.\n\ndef calculate_present_value(cashflow: float, discount_rate: float = 0.1) -&gt; float:\n    return cashflow / (1 + discount_rate)\n\n\n# Uses default discount_rate of 10%\npv = calculate_present_value(cashflow=100.00)\nprint(f\"Present Value: {pv}\")\n\n# Uses discount_rate of 5%\npv2 = calculate_present_value(cashflow=100.00, discount_rate=0.05)\nprint(f\"Present Value: {pv2}\")\n\nPresent Value: 90.9090909090909\nPresent Value: 95.23809523809524\n\n\nParameters with default values must come after parameters without default values. Otherwise, the function call will raise a SyntaxError. When you call a function with default parameters, you can omit any parameters that have a default value. However, when you omit a parameter, you must use keyword parameters to specify the values for the parameters that follow it.\n\n\n3.11.2 Passing arguments: peek under the hood\nPython uses a mechanism called “passing arguments by assignment.” In simple terms, this means that when you pass an argument to a function, a copy of the reference to the object is made and assigned to the function parameter.\nWhen an immutable object (like a number, string, or tuple) is passed as an argument, it is effectively passed by value. Any modifications made to the parameter within the function do not affect the original object outside the function. Changes to the parameter create a new object rather than modifying the original one.\nOn the other hand, when a mutable object (like a list or dictionary) is passed as an argument, it is effectively passed by reference. Any modifications made to the parameter within the function will affect the original object outside the function. This is because both the parameter and the original object refer to the same memory location, so changes are reflected in both.\n\n\n3.11.3 Return values\nFunctions can return a value, multiple values, or no value at all. To return a value, use the return keyword followed by the value or expression you want to return. If a function doesn’t include a return statement, it will implicitly return None. A function can contain multiple return statements, but the execution of the function will stop as soon as any of them is reached.\nA function can return a single value, such as a number, string, or a more complex data structure. A function can also return multiple values, typically in the form of a tuple. This is useful when you need to return several related results from a single function call. If a function doesn’t explicitly return a value using the return keyword, it will implicitly return None when it reaches the end of the function body.\n\ndef calculate_mean_and_median(numbers: list[float]) -&gt; tuple[float, float]:\n    mean = sum(numbers) / len(numbers)\n\n    # Sort the numbers in ascending order using the sorted() function\n    sorted_numbers = sorted(numbers)\n    length = len(sorted_numbers)\n\n    if length % 2 == 0:\n        median = (sorted_numbers[length // 2 - 1] + sorted_numbers[length // 2]) / 2\n    else:\n        median = sorted_numbers[length // 2]\n\n    return mean, median\n\n\nprices = [150.25, 1200.50, 250.00]\nmean, median = calculate_mean_and_median(prices)\nprint(f\"Mean: {mean}, Median: {median}\")\n\nMean: 533.5833333333334, Median: 250.0\n\n\n\n\n3.11.4 Scope\nIn Python, the scope of a variable refers to the region of a program where the variable is accessible and can be referenced. The scope determines the visibility and lifetime of a variable, including where it can be accessed and modified.\nWhen using Python functions, there are two main scopes to consider:\n\nLocal scope (function scope): Variables defined within a function have local scope. They are accessible only within the function where they are defined. Local variables are created when the function is called and destroyed when the function execution completes or reaches a return statement. They are not accessible outside the function.\nGlobal scope (module scope): Variables defined outside of any function in the interactive window or in a Python script, have global scope. They are accessible from anywhere within the program, including all functions.\n\nWhen a function is called, it creates a new local scope, which is independent of the global scope. Inside the function, the local scope takes precedence over the global scope. If a variable is referenced within a function, Python first checks the local scope for its existence. If not found, it then searches the global scope.\n\n# Global variable\nmessage = \"Hello\"\nx = 123\n\n\ndef say_hello(m: str):\n    # Local variable\n    message = \"Hello, World!\"\n    print(f\"local message = {message}\")\n\n    # Local variable, copied from the argument\n    print(f\"local m = {m}\")\n\n    # print(f\"global x inside function = {x}\") \n1\n\n    # Local variable\n    x = len(m)\n    print(f\"local x = {x}\")\n\n    return x\n\n\ny = say_hello(message)\n\nprint(f\"global message = {message}\")\nprint(f\"global x after function = {x}\")\nprint(f\"global y = {y}\")\n\n\n1\n\nThis will access the global x if there is no local variable with the same name. In this specific case, it will cause an error because x is actually defined later in the function.\n\n\n\n\nlocal message = Hello, World!\nlocal m = Hello\nlocal x = 5\nglobal message = Hello\nglobal x after function = 123\nglobal y = 5\n\n\nIf you want to modify a global variable from within a function, you can use the global keyword to indicate that the variable being referred to is a global variable rather than creating a new local variable. However, this is generally not recommended, as it can lead to unexpected side effects and make the code difficult to understand and debug.\nIt is important to carefully manage variable scope to avoid naming conflicts and unintended side effects. Understanding the scope of variables helps in organizing and managing data within functions and modules effectively."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#loops",
    "href": "introduction-to-python/python-basics/index.html#loops",
    "title": "3  Python Basics",
    "section": "3.12 Loops",
    "text": "3.12 Loops\nLoops enable you to easily perform repetitive tasks or iterate through data structures, such as sequences and collections. Python provides two primary loop constructs: the for loop and the while loop.\n\n3.12.1 for loops\nFor loops in Python are used to iterate over a sequence (e.g., a list, tuple, or string) or other iterable objects. The loop iterates through each item in the sequence, executing a block of code for each item. The ‘for’ loop has the following syntax:\nfor item in sequence:\n    # code to execute for each item in the sequence\nAs for function bodies and conditional statements, the code block in a loop must be indented.\n\n\n3.12.2 range() function\nThe built-in range() function in Python is often used in conjunction with for loops to generate a sequence of numbers. This function can be used to create a range of numbers with a specified start, end, and step size. The syntax for the range function is:\nrange(start, stop, step)\nThe ‘start’ and ‘step’ arguments are optional, with default values of 0 and 1, respectively. The ‘stop’ argument is required and defines the upper limit of the range (exclusive).\n\n1for i in range(5):\n    print(i)\n\n\n1\n\nThe range(5) function generates a sequence of numbers from 0 to 4 (inclusive) with a step of 1.\n\n\n\n\n0\n1\n2\n3\n4\n\n\n\n1for i in range(2, 7):\n    print(i)\n\n\n1\n\nThe range(2, 7) function generates a sequence of numbers from 2 to 6 (inclusive) with a step of 1.\n\n\n\n\n2\n3\n4\n5\n6\n\n\n\n1for i in range(1, 11, 2):\n    print(i)\n\n\n1\n\nThe range(1, 11, 2) function generates a sequence of numbers from 1 to 10 (inclusive) with a step of 2.\n\n\n\n\n1\n3\n5\n7\n9\n\n\nYou can use a negative step size to generate a sequence of numbers in reverse order.\n\n1for i in range(5, 0, -1):\n    print(i)\n\n\n1\n\nThe range(5, 0, -1) function generates a sequence of numbers from 5 to 1 (inclusive) with a step of -1 (decreasing).\n\n\n\n\n5\n4\n3\n2\n1\n\n\nYou can use the range() function to generate a sequence of numbers and iterate through them using a for loop to execute some code for each number in the sequence. In this example, we use the range() function to generate a sequence of numbers from 1 to 5 (inclusive) and calculate the compound interest for each year of an investment.\n\nprincipal = 1000\nrate = 0.05\n\nfor year in range(1, 6):\n    interest = principal * ((1 + rate) ** year - 1)\n    print(f\"Year {year}: Interest = {interest:.2f}\")\n\nYear 1: Interest = 50.00\nYear 2: Interest = 102.50\nYear 3: Interest = 157.63\nYear 4: Interest = 215.51\nYear 5: Interest = 276.28\n\n\n\n\n3.12.3 continue and break statements\nYou can use the continue and break statements to control the flow of a for loop. The continue statement skips the current iteration and continues with the next one. The break statement terminates the loop and transfers execution to the statement immediately following the loop.\n\nfor i in range(10):\n    if i == 3:\n1        continue\n    elif i == 5:\n2        break\n    print(i)\n\n\n1\n\nSkip the rest of the code in the loop and go to the next iteration\n\n2\n\nExit the loop\n\n\n\n\n0\n1\n2\n4\n\n\n\n\n3.12.4 for loops with lists\nYou can also loop over a collection of items using the for loop. For example, you can loop over a list of numbers to calculate the sum of all numbers in the list.\n\ndaily_profit_losses = [1500, 1200, 1800, 2300, 900]\n\ntotal_pl = 0\nfor pl in daily_profit_losses:\n    total_pl += pl\n\nprint(f\"Total P&L for the period: {total_pl}\")\n\nTotal P&L for the period: 7700\n\n\n\n\n\n\n\n\nBuilt-in functions\n\n\n\nPython provides several built-in functions that can be used to perform common tasks. For example, the sum() function can be used to calculate the sum of all numbers in a list.\n\ndaily_profit_losses = [1500, 1200, 1800, 2300, 900]\ntotal_pl = sum(daily_profit_losses)\nprint(f\"Total P&L for the period: {total_pl}\")\n\nTotal P&L for the period: 7700\n\n\n\n\nYou can combine two lists of the same length using the zip() built-in function to loop over both lists at the same time.\n\nstock_prices = [150.25, 1200.50, 250.00]\nquantities = [10, 5, 20]\n\ntotal_value = 0\nfor price, quantity in zip(stock_prices, quantities):\n    total_value += price * quantity\n\nprint(f\"Total value of the portfolio: {total_value:.2f}\")\n\nTotal value of the portfolio: 12505.00\n\n\nYou can use the enumerate() function to loop over a list and get the index of each item in the list.\n\ncash_flows = [100, 200, 300, 400, 500]\n\ndiscount_rate = 0.1\n\npresent_values = []\nfor year, cash_flow in enumerate(cash_flows):\n    present_value = cash_flow / (1 + discount_rate) ** year\n    print(f\"Year {year}: Present Value = {present_value:.2f}\")\n\nYear 0: Present Value = 100.00\nYear 1: Present Value = 181.82\nYear 2: Present Value = 247.93\nYear 3: Present Value = 300.53\nYear 4: Present Value = 341.51\n\n\n\n\n\n\n\n\nIterables and iterators\n\n\n\nIn Python, an iterable is an object capable of returning its elements one at a time, such as a list, tuple, or string. An iterator is an object that keeps track of its current position within an iterable and provides a way to access the next element when required.\nMany built-in data types and functions return values in Python are iterables or iterators. For example, the range() function returns an iterator that produces a sequence of numbers. The zip() function returns an iterator that produces tuples containing elements from the input iterables. The enumerate() function returns an iterator that produces tuples containing the index and value of each item in the input iterable.\nThere are many benefits to iterators, such as better memory efficiency and allowing you to work with infinite sequences, such as the sequence of all prime numbers. However, you can’t print the result of calling an iterator like zip() directly. Instead, you must convert the iterator to a list or another collection using the list() function.\n\nstock_prices = [150.25, 1200.50, 250.00]\nquantities = [10, 5, 20]\n\nzipped = zip(stock_prices, quantities)\n\nprint(f\"zipped: {zipped}\")\nprint(f\"list(zipped): {list(zipped)}\")\n\nzipped: &lt;zip object at 0x141411000&gt;\nlist(zipped): [(150.25, 10), (1200.5, 5), (250.0, 20)]\n\n\n\n\n\n\n\n3.12.5 Nested for loops\nYou can nest loops. The inner loop will be executed one time for each iteration of the outer loop.\nIn this example, we have a list of products, each with a name, per-item profit margin, and a list of quantities sold at different times. The outer loop iterates through each product, while the inner loop iterates through the quantities for each product. The product’s profit is calculated by multiplying its margin by the quantity sold and adding it to the product_profit variable. The total_profit variable accumulates the profit for all products.\n\nproducts = [\n    {\"name\": \"Product A\", \"margin\": 10, \"quantities\": [5, 10, 15]},\n    {\"name\": \"Product B\", \"margin\": 20, \"quantities\": [2, 4, 6]},\n    {\"name\": \"Product C\", \"margin\": 30, \"quantities\": [1, 3, 5]},\n]\n\ntotal_profit = 0\n\nfor product in products:\n    product_profit = 0\n    for quantity in product[\"quantities\"]:\n        product_profit += product[\"margin\"] * quantity\n    total_profit += product_profit\n    print(f\"Profit for {product['name']}: {product_profit}\")\n\nprint(f\"Total profit: {total_profit}\")\n\nProfit for Product A: 300\nProfit for Product B: 240\nProfit for Product C: 270\nTotal profit: 810\n\n\n\n\n3.12.6 while loops\nWhile loops are used to repeatedly execute a block of code as long as a specified condition is True. The while loop has the following syntax:\nwhile condition:\n    # code to execute while the condition is True\nIn this example, we use a while loop to calculate the number of years it takes for an investment to double at a given interest rate.\n\nprincipal = 1000\nrate = 0.05\nbalance = principal\ntarget = principal * 2\nyears = 0\n\nwhile balance &lt; target:\n    interest = balance * rate\n    balance += interest\n    years += 1\n\nprint(f\"It takes {years} years for the investment to double.\")\n\nIt takes 15 years for the investment to double.\n\n\nYou can use the continue statement to skip the rest of the code in the current iteration and continue with the next one and the break statement to exit a while loop before the condition becomes False."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#list-and-dictionary-comprehensions",
    "href": "introduction-to-python/python-basics/index.html#list-and-dictionary-comprehensions",
    "title": "3  Python Basics",
    "section": "3.13 List and dictionary comprehensions",
    "text": "3.13 List and dictionary comprehensions\nPython supports list and dictionary comprehensions, which allow you to create lists and dictionaries in a concise and efficient manner by transforming or filtering items from another iterable, such as a range, a tuple or another list. Comprehensions can be confusing at first, but they are a powerful tool worth learning.\n\n3.13.1 List comprehensions\nList comprehension syntax consists of square brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expression can be anything, meaning you can put in all kinds of objects in lists.\n\n# This is perfectly valid:\nsquared1 = []\nfor x in range(10):\n    squared1.append(x * x)\n\nprint(squared1)\n\n# This is much shorter!\nsquared2 = [x * x for x in range(10)]\n\nprint(squared2)\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nYou can use list comprehensions to transform items from a list into a new list using complex expressions.\n\n# Calculate the percentage change for a list of stock prices\nstock_prices = [150.25, 1200.50, 250.00, 175.00, 305.75]\npercentage_changes = [\n    (stock_prices[i + 1] - stock_prices[i]) / stock_prices[i] * 100\n    for i in range(len(stock_prices) - 1)\n]\n\nprint(\"Percentage changes:\", percentage_changes)\n\nPercentage changes: [699.0016638935108, -79.17534360683048, -30.0, 74.71428571428571]\n\n\n\n\n3.13.2 Dictionary comprehensions\nSimilar to list comprehensions, dictionary comprehensions use a single line of code to define the structure of the new dictionary.\n\n# Create a dictionary mapping numbers to their squares\nsquares = {i: i**2 for i in range(1, 6)}\n\nprint(squares)\n\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\n\n\n3.13.3 Filtering and transforming\nYou can use conditional statements in list and dictionary comprehensions to filter items from the source iterable.\n\n# Create a dictionary mapping even numbers to their cubes\neven_cubes = {i: i**3 for i in range(1, 6) if i % 2 == 0}\n\nprint(even_cubes)\n\n{2: 8, 4: 64}\n\n\nYou can transform the items in the source iterable before adding them to the new list or dictionary.\n\n# List of stock symbols and prices\nstock_data = [(\"AAPL\", 150.25), (\"GOOG\", 1200.50), (\"MSFT\", 250.00)]\n\n# Create a dictionary mapping lowercase stock symbols to their prices\nstocks = {symbol.lower(): price for symbol, price in stock_data}\n\nprint(stocks)\n\n{'aapl': 150.25, 'goog': 1200.5, 'msft': 250.0}\n\n\n\n\n3.13.4 Nested comprehensions\nYou can nest comprehensions inside other comprehensions to create complex data structures.\n\n# Create a list of (stock, prices) tuples\nstock_data = [\n    (\"AAPL\", [150.25, 150.50, 150.75]),\n    (\"GOOG\", [1200.50, 1201.00]),\n    (\"MSFT\", [250.00, 250.25, 250.50, 250.75]),\n]\n\n1stocks = [(symbol, price) for symbol, prices in stock_data for price in prices]\nprint(stocks)\n\n\n1\n\nThe comprehension is evaluated from left to right, so the prices variable is available in the second for clause.\n\n\n\n\n[('AAPL', 150.25), ('AAPL', 150.5), ('AAPL', 150.75), ('GOOG', 1200.5), ('GOOG', 1201.0), ('MSFT', 250.0), ('MSFT', 250.25), ('MSFT', 250.5), ('MSFT', 250.75)]\n\n\n\n\n\n\n\n\nNested comprehensions vs readability\n\n\n\nNested comprehensions with more than two levels can be difficult to read, so you should avoid them if possible. If you find yourself nesting comprehensions, it’s probably a good idea to use a regular for loop instead. Remember, code readability is more important than brevity."
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#pattern-matching",
    "href": "introduction-to-python/python-basics/index.html#pattern-matching",
    "title": "3  Python Basics",
    "section": "3.14 Pattern matching",
    "text": "3.14 Pattern matching\nPattern matching is a powerful feature introduced in Python 3.10. It allows you to match the structure of data and execute code based on the shape and contents of that data. It is particularly useful for working with complex data structures and can lead to cleaner and more readable code.\n\n\n\n\n\n\nPython 3.10+ only\n\n\n\nPattern matching is a new feature introduced in Python 3.10, released on October 4, 2021. If you’re using an older version of Python, or your code will be running on a system with an older version of Python, you should avoid using pattern matching.\n\n\nPattern matching is implemented using the match statement, which is similar to a switch-case statement in other languages but with more advanced capabilities. The match statement takes an expression and a series of cases. Each case is a pattern that is matched against the expression in turn. If the pattern matches, the code in that case is executed, otherwise the next case is checked. The match statement can also have a case with the wildcard pattern _, which will always match. If no pattern matches, a MatchError is raised.\n\ndef process_transaction(transaction: tuple):\n    match transaction:\n        case (\"deposit\", amount):\n            print(f\"Deposit: {amount:.2f}\")\n        case (\"withdraw\", amount):\n            print(f\"Withdraw: {amount:.2f}\")\n        case (\"transfer\", amount, recipient):\n            print(f\"Transfer {amount:.2f} to {recipient}\")\n        case _:\n            print(\"Unknown transaction\")\n\nprocess_transaction((\"deposit\", 1000))\nprocess_transaction((\"burn\", 100.00))\nprocess_transaction((\"transfer\", 500.00, \"John Doe\"))\nprocess_transaction((\"withdraw\", 250.00))\n\nDeposit: 1000.00\nUnknown transaction\nTransfer 500.00 to John Doe\nWithdraw: 250.00"
  },
  {
    "objectID": "introduction-to-python/python-basics/index.html#footnotes",
    "href": "introduction-to-python/python-basics/index.html#footnotes",
    "title": "3  Python Basics",
    "section": "",
    "text": "A pseudo-random number is a sequence of numbers that appear random but are generated using a deterministic algorithm.↩︎\nI do not recommend using variable-length parameters unless you have a specific need for them, as they can make your code more complex and harder to read and understand.↩︎"
  }
]